<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>神秘の博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-26T10:13:47.843Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SparkleMonkey</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>莫烦PyTorch学习笔记一</title>
    <link href="http://yoursite.com/2018/11/26/PyTorch%20learning%201/"/>
    <id>http://yoursite.com/2018/11/26/PyTorch learning 1/</id>
    <published>2018-11-26T10:01:04.711Z</published>
    <updated>2018-11-26T10:13:47.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="NumPy-Vs-Torch"><a href="#NumPy-Vs-Torch" class="headerlink" title="NumPy Vs. Torch"></a>NumPy Vs. Torch</h2><a id="more"></a><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><h3 id="数据比较"><a href="#数据比较" class="headerlink" title="数据比较"></a>数据比较</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">np_data = np.arange(6).reshape((2,3))</span><br><span class="line">torch_data = torch.from_numpy(np_data)</span><br><span class="line">tensor2array = torch_data.numpy()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="string">'\nnumpy'</span>, np_data, </span><br><span class="line">    <span class="string">'\ntorch'</span>, torch_data,</span><br><span class="line">    <span class="string">'\ntensor2array'</span>, tensor2array</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numpy [[0 1 2]</span><br><span class="line"> [3 4 5]]</span><br><span class="line"></span><br><span class="line">torch tensor([[0, 1, 2],</span><br><span class="line">        [3, 4, 5]], dtype=torch.int32)</span><br></pre></td></tr></table></figure></p><h3 id="dot函数区别"><a href="#dot函数区别" class="headerlink" title="dot函数区别"></a>dot函数区别</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import torch</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">data = [[1,2], [3,4]]</span><br><span class="line">tensor = torch.FloatTensor(data)</span><br><span class="line">data2 = np.array(data)</span><br><span class="line">tensor2 = torch.FloatTensor([1,2,3,4])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="string">'\nnumpy:'</span>, np.matmul(data, data),</span><br><span class="line">    <span class="string">'\ntorch:'</span>, torch.mm(tensor, tensor),</span><br><span class="line">    <span class="string">'\nnumpy2:'</span>, data2.dot(data2),</span><br><span class="line">    <span class="string">'\ntorch2:'</span>, tensor2.dot(tensor2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numpy: [[ 7 10]</span><br><span class="line"> [15 22]]</span><br><span class="line">torch: tensor([[ 7., 10.],</span><br><span class="line">        [15., 22.]])</span><br><span class="line">numpy2: [[ 7 10]</span><br><span class="line"> [15 22]]</span><br><span class="line">torch2: tensor(30.)</span><br></pre></td></tr></table></figure></p><p>注意：<br>这里按照视频里的tensor.dot(tensor)会报错。<br>RuntimeError: dot: Expected 1-D argument self, but got 2-D<br>意思是说dot()的参数需求是一维矩阵，但是你传了一个二维矩阵，所以这里要把tensor改成一维的，<br>主要是看torch和numpy的dot()结果区别，所以我就直接搞了个tensor2变量了。<br>可以看出，numpy的dot()与matmul()结果是相同的，而torch的dot()y与mm()函数结果是不同的，<br>因为torch会将其转换成 [1,2,3,4].dot([1,2,3,4]) = 30.0，当然我们从上面报的错误就可以看出来这点了。</p><h3 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h3><p>我现在在学python嘛，然后写完题目会看看其他人的答案。解决的方法真的是多种多样的。<br>我印象很深的一个方法，是一次遍历，将链表的值存入一个列表中，然后利用列表的pop(-n)<br>弹出需要删除的那个数，真的是秀到我了，虽然说有点投机取巧的意味，因为题目最后是要求<br>返回头结点嘛，但是他输出结果是个列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;NumPy-Vs-Torch&quot;&gt;&lt;a href=&quot;#NumPy-Vs-Torch&quot; class=&quot;headerlink&quot; title=&quot;NumPy Vs. Torch&quot;&gt;&lt;/a&gt;NumPy Vs. Torch&lt;/h2&gt;
    
    </summary>
    
      <category term="莫烦PyTorch" scheme="http://yoursite.com/categories/%E8%8E%AB%E7%83%A6PyTorch/"/>
    
    
      <category term="PyTorch" scheme="http://yoursite.com/tags/PyTorch/"/>
    
  </entry>
  
  <entry>
    <title>搜索插入位置</title>
    <link href="http://yoursite.com/2018/11/20/LeetCode%2035%20Search%20Insert%20Position/"/>
    <id>http://yoursite.com/2018/11/20/LeetCode 35 Search Insert Position/</id>
    <published>2018-11-20T01:59:24.409Z</published>
    <updated>2018-11-20T10:23:56.731Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【leetcode-35】-搜索插入位置"><a href="#【leetcode-35】-搜索插入位置" class="headerlink" title="【leetcode 35】 搜索插入位置"></a>【leetcode 35】 搜索插入位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。<br>你可以假设数组中无重复元素。</p><a id="more"></a><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>输入: [1,3,5,6], 5<br>输出: 2</p><p>输入: [1,3,5,6], 2<br>输出: 1</p><p>输入: [1,3,5,6], 7<br>输出: 4</p><p>输入: [1,3,5,6], 0<br>输出: 0</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="/解决方法/"></a>/解决方法/</h2><h3 id=""><a href="#" class="headerlink" title="."></a>.</h3><p>这道题目很简单了，主要说一下优化时间的问题。<br>最早我的写法如下，花了72ms，才战胜了6.70%的提交，我考虑是因为不管数据如何，都会进入循环，浪费了时间<br>如果那种数据，长度为0，或者直接就比第一个数字小，最后一个数字大的情况，其实可以直接返回结果的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchInsert(self, nums, target):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                <span class="built_in">return</span> i</span><br><span class="line">        <span class="built_in">return</span> n</span><br></pre></td></tr></table></figure><h3 id="-1"><a href="#-1" class="headerlink" title="."></a>.</h3><p>针对以上，进行了修改，提前判断输入数据的状态，尽量提前返回节省时间，修改后如下，执行时间为44ms，<br>战胜了99.16%的提交，还是不错的。但是我们可以看到，代码量变多了，因为分情况讨论。<br>所以，一段代码的执行时间，与代码量可能不是成正比的，我以前就简单地以为，代码写得少，运行时间就会短一点，哎。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def searchInsert(self, nums, target):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        n = len(nums)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> n==0 or target&lt;nums[0]:</span><br><span class="line">            <span class="built_in">return</span> 0</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> target&gt;nums[-1]:</span><br><span class="line">            <span class="built_in">return</span> n</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt;= target:</span><br><span class="line">                <span class="built_in">return</span> i</span><br></pre></td></tr></table></figure></p><h3 id="其他的话"><a href="#其他的话" class="headerlink" title="其他的话"></a>其他的话</h3><p>其实网上还有更快的代码，但是我看了一下，那个代码量，着实有些多了，我是不想写的…基本思想是二分查找。<br>即先后各一个指针，每次用两指针中间的数mid跟target进行比较，若target偏小，则将mid设为右指针，将整个比较区间缩到前一半，反之，则缩为后一半，这样查找更快。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;【leetcode-35】-搜索插入位置&quot;&gt;&lt;a href=&quot;#【leetcode-35】-搜索插入位置&quot; class=&quot;headerlink&quot; title=&quot;【leetcode 35】 搜索插入位置&quot;&gt;&lt;/a&gt;【leetcode 35】 搜索插入位置&lt;/h2&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;br&gt;你可以假设数组中无重复元素。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>有序数组中的单一元素</title>
    <link href="http://yoursite.com/2018/11/16/LeetCode%20540%20Single%20Element%20in%20a%20Sorted%20Array/"/>
    <id>http://yoursite.com/2018/11/16/LeetCode 540 Single Element in a Sorted Array/</id>
    <published>2018-11-16T08:54:47.934Z</published>
    <updated>2018-11-16T09:34:30.117Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【leetcode-540】-有序数组中的单一元素"><a href="#【leetcode-540】-有序数组中的单一元素" class="headerlink" title="【leetcode 540】 有序数组中的单一元素"></a>【leetcode 540】 有序数组中的单一元素</h2><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p><a id="more"></a><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>输入: [1,1,2,3,3,4,4,8,8]<br>输出: 2</p><p>输入: [3,3,7,7,10,11,11]<br>输出: 10</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>您的方案应该在 O(log n)时间复杂度和 O(1)空间复杂度中运行。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="/解决方法/"></a>/解决方法/</h2><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>这道题目简单的一点在于，这个数组本身已经是一个有序的数组了，那么我们就可以直接遍历的时候对元素进行比较。<br>因为元素是成对出现的，我们只要比较i和i+1位置的数值是否相同即可。<br>这里要注意的一点是for..in..循环的条件，我是用的range(0,n,2)要注意range函数的步长。<br>如果步长还是1的话即range(n)结果就错了，元素是成对出现，你这样写的话<br>eg. [1,1,2,3,3]<br>    期望值为2<br>    输出为1<br>因为步长为1，所有的元素都会跟他后面的元素进行比较，但其实我们只需要比较奇数位的就好了。<br>这里我还先对i的大小进行了一个判断，考虑到结果可能会是数组的最后一个数，那么取nums[i+1]就会出错了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNonDuplicate(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#比较</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(0,n,2):</span><br><span class="line">            <span class="keyword">if</span> i==(n-1):</span><br><span class="line">                <span class="built_in">return</span> nums[i]</span><br><span class="line">            <span class="keyword">elif</span> nums[i]!=nums[i+1]:</span><br><span class="line">                <span class="built_in">return</span> nums[i]</span><br></pre></td></tr></table></figure><h3 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a>异或运算</h3><p>非常厉害的方法，我也是听同学讲的，刚开始不懂为什么要用异或运算，后面是不理解异或运算在这道题目的实现机制。<br>简单说一下就是，0和一个数字异或，得到的结果还是这个数字；两个相同的数字异或，结果是0.<br>所以这道题目简单了，直接一个遍历异或运算下去，最后得到的结果就是要求出的那个数字。<br>是不是不太懂为什么一堆数字异或下去可以直接得到结果？<br>我后面又仔细想了想，来说下我的理解吧:<br>异或运算是对一个数字二进制进行运算，我们都知道二进制的表达，只有两种，0和1，异或运算如下<br>0^0 -&gt;0<br>0^1 -&gt;1<br>1^0 -&gt;1<br>1^1 -&gt;0<br>0跟一个数字异或是不会影响到那个位置原本的数字的，只有1会改变那个位置原本的数字，所以我们只要考虑1就好了。<br>而1是什么，1是一个系数，比如5这个数字二进制101，就是1x2(2) + 0x2(1) + 1x2(0)  【2(2)这里表示2的2次方，其他同理】<br>成对出现的数字，他们二进制每个位置上的’1’个数也是成对出现的，所以异或下来，剩下的位置上的’1’都是那个落单数的系数，所以结果就是要求的那个数字。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def singleNonDuplicate(self, nums):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type nums: List[int]</span></span><br><span class="line"><span class="string">        :rtype: int</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#异或</span></span><br><span class="line">        result = 0</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            result = result ^ i</span><br><span class="line">        <span class="built_in">return</span> result</span><br></pre></td></tr></table></figure><h3 id="其他要说的话"><a href="#其他要说的话" class="headerlink" title="其他要说的话"></a>其他要说的话</h3><p>这两种方法对这道题时间复杂度都是n，但是如果，给出的数组是无序的，那么明显就是第二种方法更胜一筹了。<br>对于无序的数组，除了异或，你当然也可以先对无序数组进行排序，这样就把题目转换成了这道题目，然后进行比较，但是这样你要考虑到排序操作带来的时间复杂度。还有其他方法，比如新建一个列表，对原列表进行扫描，每次取出一个数字，判断他是否在新列表里出现了，出现的话，就删除新列表的数字，没有的话就把他加入新列表，这样，最后新列表里剩的数字就是单个的数字了，这种就很麻烦了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;【leetcode-540】-有序数组中的单一元素&quot;&gt;&lt;a href=&quot;#【leetcode-540】-有序数组中的单一元素&quot; class=&quot;headerlink&quot; title=&quot;【leetcode 540】 有序数组中的单一元素&quot;&gt;&lt;/a&gt;【leetcode 540】 有序数组中的单一元素&lt;/h2&gt;&lt;p&gt;给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>删除链表的倒数第N个节点</title>
    <link href="http://yoursite.com/2018/11/13/LeetCode%2019%20Remove%20Nth%20Node%20From%20End%20of%20List/"/>
    <id>http://yoursite.com/2018/11/13/LeetCode 19 Remove Nth Node From End of List/</id>
    <published>2018-11-13T06:36:16.104Z</published>
    <updated>2018-11-15T10:05:04.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="【leetcode-19】-删除链表的倒数第N个节点"><a href="#【leetcode-19】-删除链表的倒数第N个节点" class="headerlink" title="【leetcode 19】 删除链表的倒数第N个节点"></a>【leetcode 19】 删除链表的倒数第N个节点</h2><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><a id="more"></a><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>给定的 n 保证是有效的。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><p>你能尝试使用一趟扫描实现吗？</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="/解决方法/"></a>/解决方法/</h2><h3 id="两趟扫描"><a href="#两趟扫描" class="headerlink" title="两趟扫描"></a>两趟扫描</h3><p>比较简单的想法即为，先遍历一遍链表，求出链表的长度，然后减去n，再第二次遍历进行删除即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head, n):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">if</span> n==0:</span><br><span class="line">            <span class="built_in">return</span> head</span><br><span class="line">        </span><br><span class="line">        num = 1</span><br><span class="line">        new_head = head</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> new_head.next:</span><br><span class="line">            num += 1</span><br><span class="line">            new_head = new_head.next</span><br><span class="line">               </span><br><span class="line">        <span class="keyword">if</span> num == n:</span><br><span class="line">            <span class="built_in">return</span> head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            new_head = head </span><br><span class="line">            num = num-n-1</span><br><span class="line">            <span class="keyword">while</span> num &gt; 0:</span><br><span class="line">                new_head = new_head.next</span><br><span class="line">                num -= 1</span><br><span class="line">            new_head.next = new_head.next.next</span><br><span class="line">            <span class="built_in">return</span> head</span><br></pre></td></tr></table></figure><p>我在这里分情况进行了返回，因为考虑到删除头结点的情况。所以提前进行了判断，如果n等于链表的长度num，那么直接返回head.next即可。<br>不然的话，就扫描num-n-1，即将指针指向删除节点的前一个节点，然后进行操作。<br>这里我后期看了其他优秀的解答，比如说，直接给链表增加一个无意义的头结点，这样，就能把我上面的<br>两种情况一起算了，就不会像我这样麻烦。</p><h3 id="一趟扫描"><a href="#一趟扫描" class="headerlink" title="一趟扫描"></a>一趟扫描</h3><p>这个方法有点厉害了，最早是在上数据结构课上听老师讲的，觉得这种思路挺优秀的。<br>这里我们用到两个指针，都初始化指向头结点。让第一个指针先走n步，然后两个指针一起走，当第一个指针走到<br>链表的末尾时，第二个指针恰好走到删除节点的前一个节点。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def removeNthFromEnd(self, head, n):</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        "</span><span class="string">""</span></span><br><span class="line">        </span><br><span class="line">        left, right = head, head</span><br><span class="line">        count = 0</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> right.next:</span><br><span class="line">            <span class="keyword">if</span> count &lt; n:</span><br><span class="line">                pass</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = left.next</span><br><span class="line">            right = right.next</span><br><span class="line">            count += 1</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (count+1) == n:</span><br><span class="line">            <span class="built_in">return</span> head.next</span><br><span class="line">            </span><br><span class="line">        left.next = left.next.next</span><br><span class="line">        <span class="built_in">return</span> head</span><br></pre></td></tr></table></figure><p>我这里也是考虑了两种情况，和上面说的一样，将头结点拿出来单独考虑。</p><h3 id="其他的方法"><a href="#其他的方法" class="headerlink" title="其他的方法"></a>其他的方法</h3><p>我现在在学python嘛，然后写完题目会看看其他人的答案。解决的方法真的是多种多样的。<br>我印象很深的一个方法，是一次遍历，将链表的值存入一个列表中，然后利用列表的pop(-n)<br>弹出需要删除的那个数，真的是秀到我了，虽然说有点投机取巧的意味，因为题目最后是要求<br>返回头结点嘛，但是他输出结果是个列表。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;【leetcode-19】-删除链表的倒数第N个节点&quot;&gt;&lt;a href=&quot;#【leetcode-19】-删除链表的倒数第N个节点&quot; class=&quot;headerlink&quot; title=&quot;【leetcode 19】 删除链表的倒数第N个节点&quot;&gt;&lt;/a&gt;【leetcode 19】 删除链表的倒数第N个节点&lt;/h2&gt;&lt;p&gt;给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="leetcode" scheme="http://yoursite.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/11/13/hello-world/"/>
    <id>http://yoursite.com/2018/11/13/hello-world/</id>
    <published>2018-11-13T03:43:13.510Z</published>
    <updated>2018-11-15T10:21:35.136Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
